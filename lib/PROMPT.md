We’re doing this in AWS CDK with TypeScript and deploying to us-east-1. Keep the repo minimal: three files only — bin/tap.ts (app + region), lib/tap-stack.ts (all resources), and cdk.json (project config). When the model replies, it should return only the code for those three files — no explanations, no comments, nothing extra.

The app is a simple three-tier web stack. Host the static site on S3 and put CloudFront in front of it for global delivery. Business logic runs in Lambda and is fronted by API Gateway; wire the integration so the API calls the function. Use RDS MySQL for the database layer. Stay inside security best practices: least-privilege IAM everywhere (Lambda execution role, access to the DB, any build/deploy roles, etc.), security groups locked down to just what’s needed, and encryption at rest for S3 and RDS. Use CloudWatch for metrics and logs, and turn on X-Ray so we can trace requests through Lambda. Make sure failures roll back cleanly by relying on CloudFormation Change Sets (CDK’s default flow is fine).

Set the region to us-east-1 and use a common resource name prefix of MyApp so everything is easy to spot. Add a small CI/CD path with GitHub and CodePipeline, but keep it dummy so a fresh deploy passes without external wiring — a placeholder source and a no-op CodeBuild step are enough as long as the pipeline stands up and runs. Include a basic CodeBuild project to run API tests before deployment; it can be a stub that always succeeds for now. Ensure API Gateway is actually invoking Lambda, the static site is reachable through CloudFront, and the database is provisioned and reachable only from the application tier. Tag all resources for identification and cost tracking.

Return only the code for bin/tap.ts, lib/tap-stack.ts, and cdk.json.